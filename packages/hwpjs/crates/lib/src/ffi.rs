// Auto generated by Craby. DO NOT EDIT.
#[rustfmt::skip]
use craby::prelude::*;

use crate::hwpjs_impl::*;
use crate::generated::*;

use bridging::*;

#[cxx::bridge(namespace = "craby::hwpjs::bridging")]
pub mod bridging {
    struct NullableString {
        null: bool,
        val: String,
    }

    struct ToMarkdownResult {
        markdown: String,
    }

    struct ToMarkdownOptions {
        image_output_dir: NullableString,
        image: NullableString,
        use_html: bool,
        include_version: bool,
        include_page_info: bool,
    }



    extern "Rust" {
        type Hwpjs;

        #[cxx_name = "createHwpjs"]
        fn create_hwpjs(id: usize, data_path: &str) -> Box<Hwpjs>;

        #[cxx_name = "fileHeader"]
        fn hwpjs_file_header(it_: &mut Hwpjs, data: Vec<f64>) -> Result<String>;

        #[cxx_name = "toJson"]
        fn hwpjs_to_json(it_: &mut Hwpjs, data: Vec<f64>) -> Result<String>;

        #[cxx_name = "toMarkdown"]
        fn hwpjs_to_markdown(it_: &mut Hwpjs, data: Vec<f64>, options: ToMarkdownOptions) -> Result<ToMarkdownResult>;
    }

}

fn create_hwpjs(id: usize, data_path: &str) -> Box<Hwpjs> {
    let ctx = Context::new(id, data_path);
    Box::new(Hwpjs::new(ctx))
}

fn hwpjs_file_header(it_: &mut Hwpjs, data: Vec<f64>) -> Result<String, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.file_header(data);
        ret
    })
}

fn hwpjs_to_json(it_: &mut Hwpjs, data: Vec<f64>) -> Result<String, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.to_json(data);
        ret
    })
}

fn hwpjs_to_markdown(it_: &mut Hwpjs, data: Vec<f64>, options: ToMarkdownOptions) -> Result<ToMarkdownResult, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.to_markdown(data, options);
        ret
    })
}
