# 4.3.6. 컨트롤 헤더

컨트롤 문자가 존재하면 컨트롤 문자로부터 존재하는 컨트롤 정보를 생성한다.

Tag ID: HWPTAG_CTRL_HEADER

**표 64: 컨트롤 헤더**

| 자료형 | 길이(바이트) | 설명 |
|---|---|---|
| UINT32 | 4 | 컨트롤 ID |
| | | 컨트롤 ID 이하 속성들은 CtrlID에 따라 다르다. 각 컨트롤 및 개체 참고 |
| 전체 길이 | 4 | |

---

## 컨트롤 ID 파싱 주의사항 (Control ID Parsing Notes)

실제 HWP 파일 파싱 시 아래 커스텀 로직을 사용한다.

### 바이트 순서 (Byte Order)

HWP 파일에서 컨트롤 ID는 4바이트 UINT32로 저장되며, **바이트를 리버스해서 읽어야** 올바른 문자열을 얻을 수 있다. 레거시(pyhwp, hwp.js)도 리버스해서 읽는다.

**pyhwp 방식:**
```python
def decode(bytes):
    return chr(bytes[3]) + chr(bytes[2]) + chr(bytes[1]) + chr(bytes[0])
```

**Rust 구현:**
```rust
let ctrl_id_bytes = [data[3], data[2], data[1], data[0]];
let ctrl_id = String::from_utf8_lossy(&ctrl_id_bytes)
    .trim_end_matches('\0')
    .to_string();
```

**예시**
- 파일 바이트: `[0x20, 0x6C, 0x62, 0x74]` (little-endian)
- 리버스 후: `[0x74, 0x62, 0x6C, 0x20]` = `"tbl "` (테이블 컨트롤)
- 리버스하지 않으면: `" lbt"` (잘못된 파싱)

### 공백 포함 분기 처리 (Branching with Spaces)

컨트롤 ID는 **공백을 포함할 수 있으므로**, 분기 시 **공백까지 포함해서 비교**해야 한다.

주요 컨트롤 ID: `"tbl "` 테이블, `"gso "` 일반 그리기 개체, `"cold"` 단 정의, `"head"` 머리말, `"foot"` 꼬리말.

**구현 예시:**
```rust
match ctrl_id.as_str() {
    "tbl " | "gso " => parse_object_common(remaining_data)?,
    "cold" => CtrlHeaderData::ColumnDefinition,
    "head" | "foot" => CtrlHeaderData::HeaderFooter,
    _ => CtrlHeaderData::Other,
}
```

### 주의: trim_end()

`trim_end()`를 사용하면 공백이 제거되어 `"tbl "`가 `"tbl"`로 바뀌므로, **분기 처리 시 매칭되지 않을 수 있다.** 컨트롤 ID 비교 시 `trim_end()`로 끝 공백을 제거하지 말 것.
